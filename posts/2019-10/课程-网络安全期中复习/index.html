<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>课程 网络安全期中复习 - Walk Hanmei&#39;s World</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="Hanmei"><meta name=description content="特长，知识点特多，适合哪里不会查哪里。"><meta name=keywords content="Life,Coding,Journal"><meta name=generator content="Hugo 0.59.0 with theme even"><link rel=canonical href=https://nicolemayer.github.io/posts/2019-10/%E8%AF%BE%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><link href=/dist/even.c2a46f00.min.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="课程 网络安全期中复习"><meta property="og:description" content="特长，知识点特多，适合哪里不会查哪里。"><meta property="og:type" content="article"><meta property="og:url" content="https://nicolemayer.github.io/posts/2019-10/%E8%AF%BE%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/"><meta property="article:published_time" content="2019-10-28T18:57:31-07:00"><meta property="article:modified_time" content="2019-10-28T18:57:31-07:00"><meta itemprop=name content="课程 网络安全期中复习"><meta itemprop=description content="特长，知识点特多，适合哪里不会查哪里。"><meta itemprop=datePublished content="2019-10-28T18:57:31-07:00"><meta itemprop=dateModified content="2019-10-28T18:57:31-07:00"><meta itemprop=wordCount content="6052"><meta itemprop=keywords content="密码学,网络安全,"><meta name=twitter:card content="summary"><meta name=twitter:title content="课程 网络安全期中复习"><meta name=twitter:description content="特长，知识点特多，适合哪里不会查哪里。"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Hanmei@梅</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a><a href=/about><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Hanmei@梅</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/about>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>课程 网络安全期中复习</h1><div class=post-meta><span class=post-time>2019-10-28</span><div class=post-category><a href=/categories/cs%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/>CS课程学习</a></div><span class=more-meta>6052 words</span>
<span class=more-meta>13 mins read</span>
<span id=busuanzi_container_page_pv class=more-meta><span id=busuanzi_value_page_pv><img src=/img/spinner.svg alt=spinner.svg></span> times read</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#what-topics-have-i-learned-so-far>What topics have I learned so far?</a></li><li><a href=#details>Details</a><ul><li><a href=#1-cryptography-一>1. cryptography [一]</a></li><li><a href=#2-symmetric-encrption-二>2. symmetric encrption [二]</a><ul><li><a href=#2-1-特点>2.1 特点</a></li><li><a href=#2-2-des>2.2 DES</a><ul><li><a href=#2-2-1-block-cipher>2.2.1 Block cipher</a></li><li><a href=#2-2-2-basic-structure-of-des>2.2.2 Basic Structure of DES</a></li></ul></li><li><a href=#2-3-modes-of-operation>2.3 Modes of Operation</a><ul><li><a href=#2-3-1-native-ecb-mode>2.3.1 &ldquo;Native” ECB Mode</a></li><li><a href=#2-3-2-cbc-mode>2.3.2 CBC Mode</a></li><li><a href=#2-3-3-ofb-mode>2.3.3 OFB Mode</a></li><li><a href=#2-3-4-cfb-mode>2.3.4 CFB Mode</a></li><li><a href=#2-3-5-ctr-mode>2.3.5 CTR Mode</a></li><li><a href=#2-3-6-mac-mode>2.3.6 MAC Mode</a></li></ul></li><li><a href=#2-3-aes>2.3 AES</a></li></ul></li><li><a href=#3-hash-三>3. hash [三]</a><ul><li><a href=#3-1-cryptographic-hash-functions>3.1 Cryptographic Hash Functions</a></li><li><a href=#3-2-merkle-damgard-construction>3.2 Merkle-Damgard construction</a></li><li><a href=#3-3-birthday-paradox>3.3 Birthday Paradox</a></li><li><a href=#3-4-chf-from-a-block-cipher>3.4 CHF from a Block Cipher</a></li><li><a href=#3-5-hash-func-examples>3.5 Hash Func Examples</a></li><li><a href=#3-6-message-authentication>3.6 Message Authentication</a></li><li><a href=#3-7-hmac>3.7 HMAC</a></li></ul></li><li><a href=#4-asymmetric-encryption-四-五>4. asymmetric encryption [四、五]</a><ul><li><a href=#4-1-number-theory>4.1 Number Theory</a></li><li><a href=#4-2-asymmetric-cryptography>4.2 Asymmetric Cryptography</a><ul><li><a href=#4-2-1-diffie-hellman-key-exchange>4.2.1 Diffie–Hellman key exchange</a></li><li><a href=#4-2-2-rsa>4.2.2 RSA</a></li><li><a href=#4-2-3-el-gamal>4.2.3 El Gamal</a></li><li><a href=#4-2-4-the-digital-signature-standard-dss>4.2.4 The Digital Signature Standard (DSS)</a></li><li><a href=#4-2-5-zero-knowledge-proof>4.2.5 Zero-knowledge proof</a></li><li><a href=#4-2-6-fiat-shamir-identification-scheme>4.2.6 Fiat-Shamir Identification Scheme</a></li></ul></li></ul></li><li><a href=#5-authentication-identification-六>5. Authentication/Identification [六]</a><ul><li><a href=#5-1-secure-protocols>5.1 Secure Protocols</a></li><li><a href=#5-2-basis-for-authentication>5.2 Basis for Authentication</a></li><li><a href=#5-3-authentication-protocols>5.3 Authentication (Protocols)</a></li><li><a href=#5-4-the-protocol-nonces>5.4 The Protocol (Nonces)</a></li></ul></li><li><a href=#6-key-distribution-六>6. Key Distribution [六]</a></li><li><a href=#reference>Reference</a></li></ul></li></ul></nav></div></div><div class=post-content><p>特长，知识点特多，适合哪里不会查哪里。</p><h1 id=what-topics-have-i-learned-so-far>What topics have I learned so far?</h1><p>摘自<a href=https://www.ics.uci.edu/~alfchen/teaching/cs134-2019-Fall/lectures.html>课程主页</a></p><p>一、Cryptography: History and Simple Encryption Method</p><p>Topics: Historical Ciphers, Crypto Terminology</p><p>二、Encryption</p><p>Topics: Symmetric/Convential vs. Public Key Cryptograpy, Block Ciphers, DES, Other Symmetric Ciphers, AES/Rijndael, OTP (Refresher)</p><p>三、Cryptographic Hash Functions</p><p>Topics: Cryptographic Properties, Simple Hash Functions, MD5, SHA, HMAC</p><p>四、Some &ldquo;fun&rdquo; math</p><p>Topics: Groups, Rings, Fields, Euclidean Algorithm, Chinese Remainder Theorem</p><p>五、Public Key Cryptography</p><p>Topics: Diffie Hellman Key Exchange, RSA Encryption, Square-and-Multiply, El Gamal Encryption, Digital Signatures (RSA and El Gamal), Digital Signature Standard (DSS), Identification (Fiat-Shamir), Zero-Knowledge Cave</p><p>六、Authentication and Key Distribution</p><p>Topics: Definitions, Types of Authentication, Biometrics, Protocols, Key Distribution</p><h1 id=details>Details</h1><h2 id=1-cryptography-一>1. cryptography [一]</h2><p><strong>some concepts</strong>：</p><ul><li>security service</li><li>security mechanism (e.g. cryptography, system controls os 或者 db, hardware controls smartcards, policies 定期修改密码, physical controls 物理隔绝)</li><li>security attack (e.g. <strong>Interruption</strong>, <strong>Interception</strong>, <strong>Modification</strong>, <strong>Fabrication</strong> 分别对应 <strong>availability</strong> 可获得性, <strong>Confidentiality</strong> 保密性, <strong>Integrity</strong> 完整性, <strong>Authentication</strong> 认证性)</li><li>来自外部的攻击：passive threats（数据保密） / active threats（消息认证）</li><li>来自内部的攻击：发送方否认 / 接收方否认（数字签名）</li><li>open / closed design model</li></ul><blockquote><p>Closed design has many benefits. An average attacker that does not have access to the algorithm must start from understanding the algorithm before he/she can attack the system. Understanding the algorithm usually takes a very long time and the attacker must spend a lot of resource to accomplish it.</p><p>However, there are cases where the attacker has a lot of time and resources. This might be an adversary that is backed by a large company or even a nation state. Moreover, algorithms might leak for some reason. This is possible, for example, through social engineering or even angry employees that seek revenge. Closed design systems rely on the secrecy of the algorithm, and once leaked, the system is already vulnerable.</p><p>In open design, we assume that the adversary already has access to the algorithm. This in itself is already better than the closed design, because we do not have to worry about how resourceful our attackers are. Since open design algorithm assumes adversaries with arbitrary strength, they must rely on math that even the most powerful adversary cannot solve. That is why a lot of the algorithms we see in the class is based on NP-complete problems, which is assumed that there are no algorithm that solves it efficiently.</p></blockquote><p><strong>simple encryption method</strong>: shift, affine, substitution, vigenere（生成一列数与message相加）, vernam (<strong>one-time-pad</strong> 生成一列数与message异或)</p><p><strong>A cryptosystem has</strong> (at least) :</p><ul><li>Plaintext</li><li>Secret Key</li><li>Ciphertext</li><li>Encryption Algorithm</li><li>Decryption Algorithm</li></ul><p><strong>Attacks on Classical Cryptography</strong></p><ul><li>Ciphertext-only attack</li><li>Known-plaintext attack</li><li>Chosen plaintext</li><li>Chosen ciphertext</li><li>Brute force / 统计分析 / 数学分析</li></ul><p><strong>密钥长度与暴力破解时间对照表</strong></p><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/XH1wyt.jpg alt></p><p><strong>Attainable Security</strong></p><ul><li>Perfect, unconditional or “information theoretic”</li><li>Reducible or “provable”</li><li>Ad hoc 只是看起来可行</li></ul><blockquote><p>A cryptosystem with computational security is, for the mean time, unbreakable. It relies on the hardness of a NP-complete problem (such as solving discrete logarithm) to ensure the security of the system. There are no known efficient algorithms that solve such NP-complete problems, but we do not know when it might appear in the future. That is why such system is &ldquo;for the mean time&rdquo; unbreakable.</p><p>A cryptosystem with information theoretic security is provenly unbreakable. Even if software or hardware mature in the future, such systems will still be unbreakable, unlike computational security.</p><p>Proving whether a system is computationally secure or information theoretically secure is way out of what we cover in this course, but I will give you a very simple intuition behind how we can prove it.</p><p>To prove whether a system is information theoretically secure, you have to prove that a plaintext will be transformed to any possible ciphertext that is the same length as the plaintext. To achieve that, the plaintext must be encrypted with a key with the same length or larger than the plaintext. Also, the key must be chosen truly random from a given distribution. There is only one cryptosystem that does this, and it is called one-time pad.</p><p>To prove whether a system is computationally secure is a little more complex, but to give you an intuition, you can do it by proving that the security of the cryptosystem relies on the hardness of the underlying mathematical problem. This is called &ldquo;reducing&rdquo; in cryptography.</p><p>If you are interested in learning more about this, you should take a cryptography course.</p></blockquote><p><strong>Computational security</strong> 是指破解的开销 &gt; 信息本身的价值 或是 破解花费的时间 &gt; 信息的时效性</p><p><strong>kerchkoffs原则</strong> 是指加密算法应建立在算法的公开上，并且公开算法不影响明文和密钥的安全</p><p><strong>加密算法分类</strong></p><ul><li>operation type (binary/integer arithemetic)</li><li># of keys (对称/非对称)</li><li>how plaintext is processed (block cipher/stream cipher)</li></ul><h2 id=2-symmetric-encrption-二>2. symmetric encrption [二]</h2><h3 id=2-1-特点>2.1 特点</h3><ul><li>缺点: 1. key distribution (secure? efficient?) 2. management problem (remain secret both side) 3. short life time (相对而言)</li><li>优点: 1. high data throughput 2. short key size (相对) 3. simple</li><li>使用时需注意: 1. meesage transmission (安全的信道) 2. secure storage 3. strong authentication 4. digital sigature (应用)</li><li>与非对称加密对比: 非对称加密保密性较好，能持续的时间长，数字签名很高效；但是它的key size很大（相对传统加密算法，RSA有2048位，3-DES有112位，AES有216位）导致运行效率比较低，此外它的运行建立在当前人类算力的基础上，不保证将来是否行得通。</li></ul><h3 id=2-2-des>2.2 DES</h3><p>全称 data encryption standard</p><h4 id=2-2-1-block-cipher>2.2.1 Block cipher</h4><p><strong>Generic Example of Block Encryption</strong></p><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/xuZiW7.jpg alt></p><p><strong>Feistel Cipher Structure</strong></p><p>下图为1973年Horst Feistel提出，基本上所有 block encrption 都满足这个框架:
<img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/lredQA.jpg alt>
其中算法的安全性由图上4部分决定</p><p><strong>block cipher 历史</strong></p><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/4l1UZn.jpg alt></p><h4 id=2-2-2-basic-structure-of-des>2.2.2 Basic Structure of DES</h4><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/83cKzt.jpg alt></p><p>For each round, 加密 and 解密:</p><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/Ojb5W7.jpg alt></p><p>Key schedule:</p><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/sFpsrT.jpg alt></p><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/YMXopu.jpg alt></p><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/UXbsc5.jpg alt></p><p>Function F:</p><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/D28xgw.jpg alt></p><p>DES Substitution Boxes Operation:</p><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/sYkl7d.jpg alt></p><p>S盒的例子（摘自引用2）</p><p><img src=https://i.loli.net/2019/11/01/ws2WlLFOA9gya7t.jpg alt></p><p>Operation Tables of DES:</p><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/tyx1ho.jpg alt></p><p>Breaking DES (Cryptanalysis)</p><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/437lB4.jpg alt></p><p>Meet-in-the-middle ATTACK</p><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/3yKNNb.jpg alt></p><p>DES Variants</p><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/zp9WpU.jpg alt></p><h3 id=2-3-modes-of-operation>2.3 Modes of Operation</h3><p>可参考<a href=https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation>维基百科</a></p><h4 id=2-3-1-native-ecb-mode>2.3.1 &ldquo;Native” ECB Mode</h4><p>Electronic Code-Book (ECB) Mode</p><div>$$
C_i = E ( K, P_i )
$$</div><div>$$
P_i = D ( K, C_i )
$$</div><p><strong>特点：</strong></p><ul><li>同样的明文会生成相同的加密块，ciphertext 可能存在重复 (same patterns) -&gt; 容易收到 replay 攻击</li><li>Ciphertext block rearrangement is possible -&gt; block 之间交换不会影响最后的结果，所以需要在 plaintext 中加入 block numbering</li><li>加密和解密可以并行化 (random access)</li><li>Error in one ciphertext block -&gt; one-block loss</li></ul><h4 id=2-3-2-cbc-mode>2.3.2 CBC Mode</h4><p>Cipher-Block Chaining (CBC) Mode</p><div>$$
C_i = E ( K, P_i ⊕ C_{i-1} ), C_0=IV
$$</div><div>$$
P_i = D ( K, C_i ) ⊕ C_{i-1}
$$</div><p><strong>特点：</strong></p><ul><li>同样的明文会生成不同的加密块</li><li>Block rearrangement is detectable -&gt; 因为交换顺序会影响前一个block的cipher</li><li>加密无法并行化，但解密可以</li><li>Error in one <strong>ciphertext</strong> block -&gt; two-block loss</li></ul><h4 id=2-3-3-ofb-mode>2.3.3 OFB Mode</h4><p>Output Feedback (OFB) Mode</p><div>$$
C_i = E ( K, V_{i-1} ) ⊕ P_i
$$</div><div>$$
V_0=IV, . . . ,V_i = E ( K, V_{i-1} )
$$</div><div>$$
P_i = E ( K, V_{i-1} ) ⊕ C_i
$$</div><p><strong>特点：</strong></p><ul><li>同样的明文会生成不同的加密块</li><li>Block rearrangement is detectable</li><li>Key-stream is independent of plaintext</li><li>Error in one ciphertext block -&gt; one-block loss</li><li>One-block ciphertext loss -&gt; big mess</li><li>Can encrypt less than block size</li><li>Can be run in parallel if the keystream is pre-computed</li></ul><h4 id=2-3-4-cfb-mode>2.3.4 CFB Mode</h4><p>Cipher Feedback (CFB) Mode</p><div>$$
C_i = P_i ⊕ E (K, C_{i-1}), C_0=IV
$$</div><div>$$
P_i = E ( K, C_{i-1} ) ⊕ C_i
$$</div><p><strong>特点：</strong></p><ul><li>同样的明文会生成不同的加密块</li><li>Block rearrangement is detectable</li><li>Key-stream is <strong>dependent of</strong> plaintext</li><li>Bit error in one ciphertext block -&gt; one-bit + one-block loss in plaintext</li><li>Error in one ciphertext block -&gt; 1-extra-block loss</li><li>Can encrypt less than block size</li></ul><h4 id=2-3-5-ctr-mode>2.3.5 CTR Mode</h4><p>Counter (CTR) Mode</p><div>$$
C_i = E ( K, CTR ) ⊕ Pi, CTR ++
$$</div><div>$$
P_i = E ( K, CTR ) ⊕ C_i
$$</div><p><strong>特点：</strong></p><ul><li>Duplicate plaintext blocks (patterns) NOT exposed, unless?</li><li>Block rearrangement is detectable</li><li>Key-stream is independent of plaintext</li><li>加密和解密可以并行化 (random access)</li><li>Bit error in one ciphertext block -&gt; one-bit error in plaintext</li><li>One-block ciphertext loss -&gt; big mess (I think this is assuming that the receiver does not know which ciphertext block was lost. In that case he does not know which index needs to be skipped for decryption and so all the blocks after the lost block will be decrypted to garbage since their index is shifted by the number of blocks lost)</li><li>Can encrypt less than block size</li></ul><h4 id=2-3-6-mac-mode>2.3.6 MAC Mode</h4><p>Message Authentication Code (MAC) Mode</p><div>$$
C_i = E ( K, P_i ⊕ C_{i-1} ), C_0=IV
$$</div><p>What is sent or stored: $$P1, &hellip;, Pn$$, $$Cn = MAC$$</p><p>Receiver recomputes Cn with K and compares</p><p><strong>特点：</strong></p><ul><li>Encryption is the same as in CBC mode, but, ciphertext is NOT sent!</li><li>Any change in plaintext results in unpredictable changes in MAC</li></ul><blockquote><p>Q: DIfference between CBC mode and MAC mode</p><hr><p>A: First of all, <strong>MAC is not a mode of encryption</strong>. It stands for &ldquo;Message Authentication Code&rdquo; and it is used to <strong>provide integrity to the sent message</strong>.</p><p>Here is how it works:</p><p>Let&rsquo;s assume that Alice wants to send message M to Bob. If she sends only M to Bob, then Eve can easily modify M to M&rsquo;.</p><p>So, to prevent that from happening, Alice calculates MAC of M and sends both M and its MAC to Bob.</p><p>Bob can recalculate the MAC from the received M and crosscheck with the one he received from Alice. If they match, there was no tampering 篡改 to M.</p><p>Here is how Bob can recompute MAC:</p><p>Both Alice and Bob negotiate on what kind of MAC calculation algorithm they are both going to use before Alice sends the message to Bob.</p><p>Recall that in computer security, algorithms are not secret (this is called open design). Therefore, Alice and Bob both know how to use the algorithm.</p></blockquote><h3 id=2-3-aes>2.3 AES</h3><ul><li>Advanced Encryption Standard - The Rijndael Block Cipher</li><li>为找到DES的替代方案，NIST (美国国家标准与技术研究院) 发起了竞赛，要求<ul><li>Symmetric-key ciphers supporting 128, 192, and 256 bit keys</li><li>Royalty-Free</li><li>Unclassified (i.e., public domain)</li><li>Available for worldwide export</li></ul></li><li>其中第一名是 Rijndael</li><li>Allows only 128, 192, and 256-bit key sizes (unlike other candidates)</li><li>Variable input block length: 128, 192, or 256 bits. All nine combinations of key-block length possible.</li><li>Vast speed improvement over DES in both hw and sw
implementations<ul><li>8,416 bytes/sec on a 20MHz 8051</li><li>8.8 Mbytes/sec on a 200MHz Pentium Pro
<img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/b5PY8M.jpg alt>
<img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/k9YbjK.jpg alt>
<img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/ylQ29o.jpg alt>
<img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/kmD2IP.jpg alt>
<img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/x9OpJZ.jpg alt>
<img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/fX8lmZ.jpg alt></li></ul></li></ul><p>关于 implement 上相对DES的提升：</p><ul><li><p>Well-suited for software implementations on 8-bit
processors (important for “Smart Cards”)</p><ul><li>Atomic operations focus on bytes and nibbles, not 32- or 64-bit integers</li><li>Layers such as ByteSub can be efficiently implemented using small tables in ROM (e.g., &lt; 256 bytes).</li><li>No special instructions are required to speed up operation, e.g.,barrel-shifting registers on some embedded device microprocessors</li></ul></li><li><p>For 32-bit implementations:</p><ul><li>An entire round can be implemented via a fast table lookup routine on machines with 32-bit or higher word length</li><li>Considerable parallelism exists in the algorithm</li><li>Each layer of Rijndael operates in a parallel manner on the bytes of the round state, all four component transforms act on individual parts of the block</li><li>Although the Key expansion is complicated and cannot benefit much from parallelism, it only needs to be performed once when the two parties switch keys</li></ul></li><li><p>Hardware Implementations</p><ul><li>Rijndael performs very well in software, but there are cases when better performance is required (e.g., server and VPN applications).</li><li>Multiple S-Box engines, round-key XORs, and byte shifts can all be implemented efficiently in hardware when absolute speed is required</li><li>Small amount of hardware can vastly speed up 8-bit implementations</li></ul></li><li><p>Inverse Cipher</p><ul><li>Except for the non-linear ByteSub step, each part of Rijndael has a straightforward inverse and the operations simply need to be undone in the reverse order.</li><li>However, Rijndael was specially written so that the same code that encrypts a block can also decrypt the same block simply by changing certain tables and polynomials for each layer. The rest of the operation remains identical.</li></ul></li></ul><h2 id=3-hash-三>3. hash [三]</h2><h3 id=3-1-cryptographic-hash-functions>3.1 Cryptographic Hash Functions</h3><ul><li>缩写：CHF</li><li>优秀的密码学hash函数性质 ( ✅表示本身hash function就具有的功能 )<ol><li>Takes on input of any size ✅</li><li>Produces fixed-length output ✅</li><li>Easy to compute (efficient) ✅</li><li>Given any <code>h</code>, computationally infeasible to find any <code>x</code> such that <code>H(x) = h</code> ➡️ One-Way-ness</li><li>For a given <code>x</code>, computationally infeasible to find <code>y</code>: <code>H(y) = H(x)</code> and <code>y≠x</code> ➡️ Weak Collision-Resistance</li><li>Computationally infeasible to find any <code>(x, y)</code> such that <code>H(x) = H(y)</code> and <code>x ≠ y</code> ➡️ Strong Collision-Resistance</li></ol></li></ul><h3 id=3-2-merkle-damgard-construction>3.2 Merkle-Damgard construction</h3><ul><li>compression function f(): fixed-size</li></ul><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/QeQpw9.jpg alt></p><h3 id=3-3-birthday-paradox>3.3 Birthday Paradox</h3><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/TBauCd.jpg alt>
<img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/QU4JkU.jpg alt></p><p><strong>How long should a hash be?</strong></p><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/Ro9oPX.jpg alt></p><p>个人认为这里的1/2是根据上面的图估计出来的，详情见<a href=https://iacr.org/archive/eurocrypt2004/30270396/bk.pdf>论文 Hash Function Balance
and its Impact on Birthday Attacks</a></p><h3 id=3-4-chf-from-a-block-cipher>3.4 CHF from a Block Cipher</h3><ol><li>Split input into a sequence of keys: <code>M1,…Mp</code></li><li>Encrypt a constant plaintext (e.g., block of
zeros) with this sequence of keys: <code>Hi = E ( Mi, Hi-1 ), H0= 0</code></li><li>Final ciphertext <code>Hp</code> is the hash output</li></ol><p><strong>Davies-Meyer CHF</strong> 加密方程为异或⊕</p><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/V3s0Pp.jpg alt></p><h3 id=3-5-hash-func-examples>3.5 Hash Func Examples</h3><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/7cqjND.jpg alt></p><p><strong>Latest standard: SHA-3</strong></p><ul><li><p>仍然是 NIST (美国国家标准与技术研究院) 发起的一场竞赛，07年开始征求协议，08年有51份提交，09年14份进入半决赛，最后10年5份决赛，最终的胜出者是 Keccak</p></li><li><p>Designed by Bertoni, Daemen, Peeters, Van Assche.</p></li><li><p>Based on “<strong>sponge construction</strong>” <a href=https://zh.wikipedia.org/wiki/%E6%B5%B7%E7%B6%BF%E5%87%BD%E6%95%B8>海绵函数</a>, a completely
different structure from prior CHF-s.</p></li></ul><h3 id=3-6-message-authentication>3.6 Message Authentication</h3><p>哈希函数除了能保证消息的完整性，还能应用于 Message Authentication：
<img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/uVfdGM.jpg alt></p><p>下面那种方法比上面的更简单，不需要加密解密，只需要比较哈希值就行。我原来注明了它是Challenge-response authentication 但其实不太一样，后者更加复杂，详见<a href=https://medium.com/@nipunadilhara/challenge-response-authentication-protocol-850925f50813>链接</a>。</p><h3 id=3-7-hmac>3.7 HMAC</h3><ul><li>Just computing and appending H(m) to m is enough for integrity but not for authenticity 这句话意思是我们将哈希后得到的 message digest 附在原来的 message 后面只能用作验证文本的完整性，但我们无法用来验证身份。我们需要一个“Keyed Hash”</li></ul><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/W99qhw.jpg alt>
<img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/sL1vUS.jpg alt></p><p><strong>算法流程</strong></p><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/JjjYnB.jpg alt></p><h2 id=4-asymmetric-encryption-四-五>4. asymmetric encryption [四、五]</h2><h3 id=4-1-number-theory>4.1 Number Theory</h3><p><strong>4.1.1 判断有限代数结构（Finite Algebraic Structures）</strong></p><ol><li><strong>Group (G,@)</strong>: closure / associativity / identity / inverse</li><li><strong>Abelian 阿贝尔群/交换群</strong>: commutativity</li><li><strong>Cyclic</strong>: group generator <code>G=&lt;g&gt;</code></li><li><strong>Order of a group</strong>: the size of set G <code>|G|</code> or <code>#{G}</code> or <code>ord(G)</code></li><li>Group (G,@) is finite if ord(G) is finite</li><li><strong>Rings (R, +, *)</strong>： (R, +) is an Abelian group (identity=0) &amp; closure / associativity / identity=1 / distribution</li><li><strong>Monoid</strong>: associative / identity</li><li><strong>Fields (F, +, *)</strong>: Commutative Ring + Inverse(*)</li><li><strong>Subgroup (G,@)</strong>: H is a subset of G &amp; (H, @) is a group</li></ol><p>Some cases hard to understand:</p><ol><li>Integers mod(p) (where p is Prime) under Multiplication -&gt; Nonzero integers mod p -&gt; 这个集合包含所有模p等于1,2,&hellip;,(p-1)的数</li><li>non-zero integers mod N = {1 …, x, … n-1} such that GCD(x, N)=1 -&gt; 这个集合包含所有模n等于1,2,&hellip;,(n-1)的数，和前一个的区别在于这里 N 不一定是质数，任何数都可以</li></ol><p><strong>4.1.2 extended euclidian algorithm</strong></p><p><img src=https://i.loli.net/2019/10/29/CVGBUunti3WI9rQ.jpg alt>
<img src=https://i.loli.net/2019/10/29/yiuMNqWR3kcsGpm.jpg alt></p><p><strong>4.1.3 chinese remainder theorem(CRT)</strong></p><p><img src=https://i.loli.net/2019/10/29/x9sGP576EgHfIkY.jpg alt>
<img src=https://i.loli.net/2019/10/29/6T5AFeMiRXrPQDc.jpg alt></p><h3 id=4-2-asymmetric-cryptography>4.2 Asymmetric Cryptography</h3><ul><li>也叫 Public Key Cryptography</li><li>优点：no key distribution problem</li><li>缺点：slow (对称 - bitwise operation / 非对称 - multiplication, exponentiation and modular arithmetic)</li><li>Encryption done with public key, decryption done with private key</li><li>Digital signatures<ul><li>Signing done with private key, verification done with public key</li><li>Signature is encryption of message hash and provided along with the message 【Q:所以说传递的信息为：原信息+原信息哈希后经过加密的签名？A:发送报文时，发送方用一个哈希函数从报文文本中生成报文摘要,然后用对方的公钥对这个摘要进行加密，这个<strong>加密后的摘要</strong>将<strong>作为报文的数字签名</strong>和<strong>报文</strong>一起发送给接收方，接收方首先用与发送方一样的哈希函数从接收到的原始报文中计算出报文摘要，接着再用接收方的私钥来对报文附加的数字签名进行解密，如果这两个摘要相同、那么接收方就能确认该数字签名是发送方的。(from 百度百科)】</li><li>Provides authentication (认证，是不是对方发的？), integrity (消息有没有被中间人恶意篡改？), and non-repudiation (不可抵赖的)</li></ul></li></ul><h4 id=4-2-1-diffie-hellman-key-exchange>4.2.1 Diffie–Hellman key exchange</h4><p>wiki: <strong>迪菲-赫尔曼密钥交换</strong>是一个匿名（无认证）的密钥交换协议。它可以让双方在完全没有对方任何预先信息的条件下 <em>通过不安全信道创建起一个密钥</em> ，这个密钥可以在后续的通讯中作为对称密钥来加密通讯内容。它是很多认证协议的基础，并且被用来提供传输层安全协议的短暂模式中的前向安全性。（后一篇离散数学的post最后部分也关于这个过程的流程图）</p><p><img src=https://i.loli.net/2019/10/30/QwkRIBEsDWKJu6P.jpg alt>
<img src=https://i.loli.net/2019/10/30/96JgBMaAXbUpRqj.jpg alt></p><p>当然，所有算法可行的前提是它们的问题是 HARD 的，不属于 P class；有点不理解DH和DDH的区别，<a href=https://crypto.stackovernet.com/cn/q/1183>这个回答</a>提供了帮助：
<img src=https://i.loli.net/2019/10/30/vPCQiO8gcaJBAl9.jpg alt></p><p>此外，Diffie–Hellman只有当攻击者处于监听状态（passive）时才有效，如果你正在和一个伪装成别人的攻击者（active）通信，这种交换协议是无效的。</p><p>那有没有可能利用对称加密来交换密钥呢？答案就是 Merkle’s Puzzles (1974) <a href="https://www.youtube.com/watch?v=e3VxAM2oqYI">🔗</a>
<img src=https://i.loli.net/2019/10/31/Y2aquK7TWHCVkR8.jpg alt></p><h4 id=4-2-2-rsa>4.2.2 RSA</h4><p><img src=https://i.loli.net/2019/10/30/eqtgCHT9BpW2sNo.jpg alt></p><p><strong>Why does it all work?</strong>
在这个地方卡了很久都没看懂想说明什么，严重影响复习效率。后来翻几个推荐的textbook，发现有一本（Network Security: Private Communication in a Public World）刚好能对上。课件拌书食用，效果更佳！</p><p>这里是想证明 <code>x^de = x mod n</code>, 所以才可以还原加密的内容。<a href=https://baike.baidu.com/item/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AE%9A%E7%90%86>拉格朗日定理</a>是说 for any g in G, ord(g) divides ord(G)，网上没怎么查到这一定理，大概是其它定理更有名？</p><p><img src=https://i.loli.net/2019/10/29/ZMiG1L6jcX3OdS7.jpg alt></p><p><strong>Why secure?</strong></p><ul><li>Conjecture: breaking RSA is polynomially equivalent to factoring n</li><li><p>Recall that n is very, very large</p></li><li><p>Why: n has unique factors p, q; Given p and q, computing (p-1) (q-1) is easy</p><ul><li><code>ed ≡ 1 mod Φ(mn)</code></li><li>Use extended Euclidian</li></ul></li></ul><p><strong>复杂度分析</strong></p><ul><li><p>可以参考<a href=https://crypto.stackexchange.com/questions/6164/how-do-i-derive-the-time-complexity-of-encryption-and-decryption-based-on-modula>链接</a>
<img src=https://i.loli.net/2019/10/30/S6IzMabfkVsoE9h.jpg alt></p></li><li><p>Square-and-Multiply 也叫 快速幂 或 平方求幂 <a href=https://zh.wikipedia.org/wiki/%E5%B9%B3%E6%96%B9%E6%B1%82%E5%B9%82>🔗</a>
<img src=https://i.loli.net/2019/10/30/WIaNQkK8S9gDEUl.jpg alt></p></li><li><p>Speeding up RSA Decryption 利用中国剩余定理，p、q比n小的多，计算得更快
<img src=https://i.loli.net/2019/10/30/IOFZztmUNx5fwsY.jpg alt></p></li><li><p>2 or more parties cannot share the same n
<img src=https://i.loli.net/2019/10/30/7thNQcqpnoB9POH.jpg alt></p></li></ul><p><strong>RSA Signature Scheme</strong></p><p><img src=https://i.loli.net/2019/10/29/R5GwWYpXmQVxtTr.jpg alt></p><ul><li><p>这种方法是不安全的</p><ul><li>In practice, we use a randomized version of RSA (implemented in PKCS#1)</li><li><strong>Hash the message</strong> and then <strong>sign the hash</strong></li></ul></li><li><p>The Good:</p><ul><li>Verification can be cheap (like RSA encryption)</li><li>Mechanically same as RSA decryption function</li><li>Security based on RSA encryption</li><li>Signing is harder but #verify-s &gt; 1 …</li><li>Deterministic</li></ul></li><li><p>The Bad: <a href=https://crypto.stackexchange.com/questions/12768/why-hash-the-message-before-signing-it-with-rsa>🔗</a> 如果不使用HASH函数的后果</p><ul><li>RSA is malleable: signatures can be “massaged” 交换顺序或者直接扔掉一串<ul><li><code>m1^d * m2^d = (m1*m2)^d</code></li><li>（存在性伪造）使用“已知消息攻击” 拼接之前的签名</li><li>（选择性伪造）利用“选择消息攻击” 请求多个签名拼接</li></ul></li><li>Phony “random” signatures 任何人都能提供随机选择 y, 并计算 m = y^e mod n 来伪造签名者对随机消息m的签名</li><li>compute <code>Y=RSA(e,X)=X^e mod n</code><ul><li>X is a signature of Y because <code>Y^d=X mod n</code></li><li>唯密钥攻击的存在性伪造</li></ul></li><li>解决措施就是引入哈希函数，使得消息包含足够多的多余度<br></li></ul></li><li><p>The Ugly:</p><ul><li>Signing requires integrity!</li><li>How to sign multiple blocks when m &gt; n?</li><li>Deterministic – needs additional randomization!</li></ul></li></ul><h4 id=4-2-3-el-gamal>4.2.3 El Gamal</h4><p><img src=https://i.loli.net/2019/10/29/E3nrNmskwqid7bf.jpg alt></p><ul><li>The good:<ul><li>Signing is cheap(er)</li><li>Designed as a signature function</li><li>Non-deterministic (randomized)</li></ul></li><li>The bad:<ul><li>Need GOOD source of random numbers</li><li>Randomizers cannot be revealed (trace)</li><li>Randomizers cannot be reused</li></ul></li></ul><h4 id=4-2-4-the-digital-signature-standard-dss>4.2.4 The Digital Signature Standard (DSS)</h4><ul><li>Why DSS<ul><li>RSA issues: patents, malleability, etc.</li></ul></li><li>A variant of El Gamal, but better performance</li><li>Originally for |p|=512 bits, now up to 1024</li><li>Optimized for signature size (320- vs. 1024-bit)</li><li>Signing - 1 exp, 1 inv, verification - 2 exps, 1 inv</li><li>No attacks thus far
左边是EI，右边是DSS
<img src=https://i.loli.net/2019/10/31/P9MltcLGVXnmqHr.jpg alt></li></ul><h4 id=4-2-5-zero-knowledge-proof>4.2.5 Zero-knowledge proof</h4><ul><li>prove ownership of a secret without revealing any info about the secret
<img src=https://i.loli.net/2019/10/31/er8waUJPKGRSzBO.jpg alt></li></ul><h4 id=4-2-6-fiat-shamir-identification-scheme>4.2.6 Fiat-Shamir Identification Scheme</h4><p><img src=https://i.loli.net/2019/10/31/SKfVql46NP2gJWD.jpg alt>
<img src=https://i.loli.net/2019/10/31/FAyJ3eo7YtT5fKq.jpg alt>
Protocol is repeated t (usually 20, 30, or log n) times, and, if each one succeeds, V concludes that P is the claimed party.</p><p><strong>What if Prover knows the challenge ahead of time?</strong>
<img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/wOHkkN.jpg alt></p><p><img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/pv87ZC.jpg alt></p><p>⚠️这两个 x 的计算是不一样的，也就是说攻击者无法同时得出两种值（没看仔细研究了好久，还以为这个算法有漏洞&hellip;)</p><p><strong>CLAIM: Protocol does not reveal ANY information about S</strong></p><ul><li>The Fiat-Shamir protocol is ZERO-KNOWLEDGE
<img src=https://my-blog-1300567649.cos.ap-shenzhen-fsi.myqcloud.com/t6CDx7.jpg alt></li></ul><p><strong>安全性分析</strong></p><ul><li>Clearly, if P knows S, then V is convinced of P’s identity</li><li>If P does not know S, it can either:<ul><li>know R, but not RS mod n. Since P is choosing R, it cannot multiply it by the unknown value S</li><li>choose RS mod n, and thus can answer the second question: RS mod n. But, in this case, P cannot answer the first question R, since to do so, needs to divide by unknown S</li></ul></li><li>In any case, adversary cannot answer both questions, since otherwise he can compute S as the ratio between the two answers.</li><li>But, we assumed that computing S is hard, equivalent to factoring n.</li><li>Since P does not know in advance (when choosing R or RS mod n) which question that V will ask, he cannot foresee the required choice. He can succeed in guessing V’s question with probability <sup>1</sup>&frasl;<sub>2</sub> for each question.</li><li>The probability that V fails to catch P in all runs is thus: 2^(-t)<ul><li>e.g., 1 in 1,000,000,000 for t=20</li></ul></li></ul><h2 id=5-authentication-identification-六>5. Authentication/Identification [六]</h2><h3 id=5-1-secure-protocols>5.1 Secure Protocols</h3><ul><li>A <strong>protocol</strong> is a set of rules for exchanging messages between 2 or more <strong>entities/parties</strong></li><li>A protocol has a number of <strong>rounds</strong> (&gt;1) and a number of <strong>messages</strong> (&gt;1)</li><li>A <strong>message</strong> is a unit of information/data sent from one entity/party to another as part of a protocol</li><li>A <strong>round</strong> is a basic unit of protocol time</li><li><p>When acting honestly, <strong>entities=parties=participants</strong> achieve the stated goal of the protocol:</p><ul><li>A successfully authenticates to B, or B to A</li><li>A and B mutually authenticate each other</li><li>A and B exchange a fresh session key</li></ul></li><li><p>The Entities (2-Party Setting)</p><ul><li><strong>Alice</strong> and <strong>Bob</strong> (want to mutually authenticate and/or share a key)</li><li><strong>Eve</strong>, the adversary (passive or active)</li><li>More complex protocols may involve a <strong>Trusted Third Party (TTP)</strong> (3rd party trusted by both <strong>Alice</strong> and <strong>Bob</strong>)</li></ul></li><li><p>Entity Authentication (corroboration 确认 that an entity is the one claimed) has two types:</p><ul><li>Unilateral Authentication (providing one entity with assurance of the other’s identity, but not vice versa</li><li>Mutual Authentication (providing both entities with assurance of each other’s identity)</li></ul></li></ul><h3 id=5-2-basis-for-authentication>5.2 Basis for Authentication</h3><ul><li><p>分类</p><ul><li>Something you know, such as PIN or password</li><li>Something you have</li><li>Something you are (a biometric)</li></ul></li><li><p>具体场景</p><ul><li>PIN-, PW-, Biometric-based schemes</li><li>Kerberos 麻省理工学院开发的安全认证系统</li><li>SecureID tokens</li><li>Iris/retina scanners 虹膜/视网膜扫描仪</li><li>Thumbprint &amp; hand/palmprint 拇指指纹/掌纹和手</li><li>Handwriting acceleration &amp; pressure 测量笔迹加速度和压力</li><li>Public Key Identification Schemes:</li><li>Fiat-Shamir, etc.</li><li>Authentication protocols</li><li>Conventional- and public key-based 【covered later】</li></ul></li><li><p>分析每种方式的优点和局限性</p><ul><li>Human Failings / Biometrics / Fingerprints / Voice Recognition</li><li>Keystroke Timing 【Best done for “local” authentication - Avoid network traffic delay？？】</li><li>(Non-digital) Signatures (还可以加入写字时的压力和速度)</li><li>SecureID/Secure-Token (TTP/Server: secure &amp; knows all secrets!)
<img src=https://i.loli.net/2019/10/30/JNv4IYuPkDpg7w6.jpg alt>
<img src=https://i.loli.net/2019/10/30/nxh3JQao86OKGjC.jpg alt></li></ul></li></ul><h3 id=5-3-authentication-protocols>5.3 Authentication (Protocols)</h3><p><strong>Protocol ap1.0</strong>: Alice says “I am Alice” （坏人可以直接充当 Alice）
<img src=https://i.loli.net/2019/10/30/nq3LKwiXHWs5l7S.jpg alt>
<strong>Protocol ap2.0</strong>: Alice says “I am Alice” in an IP packet containing her source IP address （坏人可以创建一个包含 Alice 地址的包 “spoofing”）
<img src=https://i.loli.net/2019/10/30/7dJzavZntkM9NGc.jpg alt>
<strong>Protocol ap3.0</strong>: Alice says “I am Alice” and sends her secret password to “prove” it （<strong>playback attack</strong>: Eve records Alice’s packet and later plays it back to Bob）
<img src=https://i.loli.net/2019/10/30/Ndyv5npKYJxQ6sh.jpg alt>
<strong>Protocol ap3.1</strong>: Alice says “I am Alice” and sends her encrypted secret password to “prove” it（record and playback still works!）
<img src=https://i.loli.net/2019/10/30/pmX47YFusxNKTyk.jpg alt>
<strong>Protocol ap4.0</strong>: to prove Alice “live”, Bob sends Alice <strong>nonce</strong> (a number used once &reg;), <strong>R</strong>. Alice must return R, encrypted with shared secret key. K may be derived from Alice’s password … This protocol works if Bob never authenticates to Alice using K
<img src=https://i.loli.net/2019/10/30/VAUisHkLGjzNamS.jpg alt>
<strong>Protocol ap5.0</strong>: nonces and public key cryptography. Using PKA, Bob verifies Alice’s signature of R in msg3. Since R is fresh and only Alice can compute signatures using SKA, Bob concludes that Alice is really there.
<img src=https://i.loli.net/2019/10/30/bn6h14YywMurWEv.jpg alt></p><h3 id=5-4-the-protocol-nonces>5.4 The Protocol (Nonces)</h3><p><img src=https://i.loli.net/2019/10/30/Jm5nPtlO2GBribv.jpg alt>
<img src=https://i.loli.net/2019/10/30/WOVmQAYcMyCsxD9.jpg alt></p><blockquote><p>Here is what will happen:</p><p>From the slide, we can see that A initiates the protocol by stating &ldquo;I&rsquo;m Alice&rdquo; to B. B then sends the nonce R to A to see whether A is actually who she claims to be.</p><p>Therefore, the the forth arrow from E to A passing r2 will not work, <strong>since there is no way E can initiate a protocol</strong> and then send a nonce to the challenging party, A.</p><p>Now, if the encryption scheme uses a bidirection key (i.e. K), then something like p.27 will work. If the scheme uses a one-way key (i.e. Kab and Kba), then the attack shown in p.27 will not work.</p><p>Therefore, Eve has no way to conduct a MiTM attack.</p></blockquote><p><img src=https://i.loli.net/2019/10/30/BTsebdNghrxF5cJ.jpg alt></p><p><img src=https://i.loli.net/2019/10/30/dm1f5Skg94OXhoN.jpg alt>
<img src=https://i.loli.net/2019/10/30/2GbcaROuYeQMr3l.jpg alt></p><h2 id=6-key-distribution-六>6. Key Distribution [六]</h2><ul><li>Conventional (Secret) key distribution / Public key distribution</li><li><p>Trusted Intermediaries
<img src=https://i.loli.net/2019/10/30/G376wAcLBF4huvN.jpg alt></p></li><li><p><strong>Key Distribution Center (KDC)</strong></p><ul><li>也叫 Trusted Third Part (TTP)</li><li>职责是 distribute keys to pairs of users (hosts, processes, applications)</li><li>Each user must <strong>share a unique master key</strong> with the KDC<ul><li>Use this key to communicate with KDC to <strong>get a temporary session key</strong> for establishing a secure “session” with another <strong>user/program/host/entity</strong></li></ul></li><li>Each master key is distributed (agreed upon) in some off-line fashion (in person, by snail-mail, etc.)<br></li></ul></li></ul><p><img src=https://i.loli.net/2019/10/30/LFxkcIhDlPVzyQM.jpg alt></p><blockquote><p>Q：实际的应用？</p><p>A：Kerberos认证 /Cisco GetVPN（被用于分发TEK - Traffic Encryption Key）&hellip; <a href="秘钥分发中心（KDC）在实际应用中是不是使用的比较少？ - 车小胖的回答 - 知乎
https://www.zhihu.com/question/265065014/answer/289143466">来自知乎回答</a> 生动形象地描述了用户如何和服务端建立连接</p></blockquote><h2 id=reference>Reference</h2><ol><li>UCI CS134 课件（mainly）</li><li><a href="https://blog.csdn.net/qq_43573718/article/details/90407185?utm_source=app#__3">现代密码学复习要点总结（谷利泽）</a></li></ol></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>Hanmei</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2019-10-28</span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/>密码学</a>
<a href=/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/>网络安全</a></div><nav class=post-nav><a class=prev href=/posts/2019-10/20191029-%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/><i class="iconfont icon-left"></i><span class="prev-text nav-default">20191029 日常记录</span>
<span class="prev-text nav-mobile">Prev</span></a>
<a class=next href=/posts/2019-10/20191028-%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/><span class="next-text nav-default">20191028 日常记录</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js crossorigin=anonymous></script><script type=text/javascript>var gitalk=new Gitalk({id:'2019-10-28 18:57:31 -0700 -0700',title:'课程 网络安全期中复习',clientID:'8d8830a8bdd2c3ba3869',clientSecret:'5dea07f5de4151736f94f1d8921972ac32a5f8dc',repo:'hanmeimei-blog',owner:'nicolemayer',admin:['nicolemayer'],body:decodeURI(location.href)});gitalk.render('gitalk-container');</script><noscript>Please enable JavaScript to view the <a href=https://github.com/gitalk/gitalk>comments powered by
gitalk.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=nicolemeimeibest@gmail.com class="iconfont icon-email" title=email></a><a href=https://github.com/NicoleMayer class="iconfont icon-github" title=github></a><a href=https://nicolemayer.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>site pv: <span id=busuanzi_value_site_pv><img src=/img/spinner.svg alt=spinner.svg></span></span>
<span class=division>|</span>
<span id=busuanzi_container_site_uv>site uv: <span id=busuanzi_value_site_uv><img src=/img/spinner.svg alt=spinner.svg></span></span></div><span class=copyright-year>&copy;
2019
<span class=heart><i class="iconfont icon-heart"></i></span><span class=author>Hanmei</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/dist/even.26188efa.min.js></script><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$'],['\\(','\\)']]},showProcessingMessages:false,messageStyle:'none'};</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin=anonymous></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-151013261-1','auto');ga('set','anonymizeIp',true);ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>